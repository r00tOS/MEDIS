<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Patienten-Tracking</title>
    <link rel="stylesheet" href="../styles/main.css" />
    <link rel="stylesheet" href="../styles/patient.css" />
    <link rel="stylesheet" href="../styles/disposition_status.css" />
    <link rel="stylesheet" href="../styles/context_menu.css" />
    <script src="../scripts/categories.js"></script>
    <script src="../scripts/logic_patient.js"></script>
    <script src="../scripts/render_patients.js"></script>
    <script src="../scripts/status_options.js"></script>
    <script src="../scripts/logic_trupp.js"></script>
    <script src="../scripts/render_trupps.js"></script>
    <script src="../scripts/history.js"></script>
    <style>
      /* Ressourcen-Spalte an Inhalt anpassen */
      .patients-table th:last-child,
      .patients-table td:last-child {
        width: auto;
        min-width: 120px;
      }
      
      /* Verbesserte Tabellen-Responsivität */
      .table-responsive {
        overflow-x: auto;
      }
      
      .patients-table {
        width: 100%;
        table-layout: auto;
      }
      
      /* Andere Spalten flexible Breiten */
      .patients-table th:nth-child(4),
      .patients-table td:nth-child(4) {
        min-width: 180px;
      }
      
      .patients-table th:nth-child(6),
      .patients-table td:nth-child(6) {
        min-width: 100px;
      }
      
      .patients-table th:nth-child(7),
      .patients-table td:nth-child(7) {
        min-width: 120px;
      }
    </style>
  </head>
  <body>
    <script src="../scripts/main.js"></script>
    <script src="../scripts/keyword_modal.js"></script>
    <script src="../scripts/modal.js"></script>
    <header>
      <button id="btnNewPatient">Neuen Patienten erstellen</button>
      <label style="margin-left: 20px;">
        <input type="checkbox" id="showDismissedCheckbox" checked>
        Entlassene/Transportierte anzeigen
      </label>
    </header>

    <!-- Bereich, der für den Export genutzt wird -->
    <main id="exportArea">
      <section id="sectionActive">
        <h2>Aktiv</h2>
        <div class="table-responsive">
          <table id="activePatients" class="patients-table">
            <thead>
              <tr>
                <th style="width: 30px;"></th>
                <th style="width: 80px;">ID</th>
                <th style="width: 120px;">Status</th>
                <th style="width: 220px;">Diagnose</th>
                <th>Alter/Geschl.</th>
                <th>Standort</th>
                <th>Disposition</th>
                <th>Trupp/RTM</th>
              </tr>
            </thead>
            <tbody>
              <!-- Hier werden die aktiven Patienten eingefügt -->
            </tbody>
          </table>
        </div>
      </section>
      <section id="sectionInUHS">
        <h2>In UHS</h2>
        <div class="table-responsive">
          <table id="inUhsPatients" class="patients-table">
            <thead>
              <tr>
                <th style="width: 30px;"></th>
                <th style="width: 80px;">ID</th>
                <th style="width: 120px;">Status</th>
                <th style="width: 220px;">Diagnose</th>
                <th>Alter/Geschl.</th>
                <th>Standort</th>
                <th>Disposition</th>
                <th>Trupp/RTM</th>
              </tr>
            </thead>
            <tbody>
              <!-- Hier werden die UHS Patienten eingefügt -->
            </tbody>
          </table>
        </div>
      </section>
      <section id="sectionDismissed">
        <h2>Entlassen</h2>
        <div class="table-responsive">
          <table id="dismissedPatients" class="patients-table">
            <thead>
              <tr>
                <th style="width: 30px;"></th>
                <th style="width: 80px;">ID</th>
                <th style="width: 120px;">Status</th>
                <th style="width: 220px;">Diagnose</th>
                <th>Alter/Geschl.</th>
                <th>Standort</th>
                <th>Disposition</th>
                <th>Trupp/RTM</th>
              </tr>
            </thead>
            <tbody>
              <!-- Hier werden die entlassenen Patienten eingefügt -->
            </tbody>
          </table>
        </div>
      </section>
    </main>
    <script>
      //event listener für den Button "Neuen Patienten erstellen"
      document.getElementById("btnNewPatient").addEventListener("click", () => {
        const id = newPatient({});
        loadPatients(id);
        openEditModal(id);
      });

      // Event listener für die Checkbox mit localStorage-Speicherung
      document.getElementById("showDismissedCheckbox").addEventListener("change", (e) => {
        // Zustand in localStorage speichern
        localStorage.setItem("showDismissedPatients", e.target.checked);
        loadPatients();
      });

      // Checkbox-Zustand beim Laden der Seite wiederherstellen
      document.addEventListener('DOMContentLoaded', () => {
        // Checkbox-Zustand aus localStorage laden (Standard: true)
        const showDismissed = localStorage.getItem("showDismissedPatients");
        const checkbox = document.getElementById("showDismissedCheckbox");
        
        if (showDismissed !== null) {
          checkbox.checked = showDismissed === "true";
        } else {
          // Standardwert setzen falls noch nicht gespeichert
          checkbox.checked = true;
          localStorage.setItem("showDismissedPatients", "true");
        }

        // Versuche erweiterte Zustände aus sessionStorage wiederherzustellen
        const savedExpanded = sessionStorage.getItem('expandedPatients');
        if (savedExpanded) {
          try {
            const expandedArray = JSON.parse(savedExpanded);
            if (Array.isArray(expandedArray)) {
              window.expandedPatients = new Set(expandedArray);
              console.log('Wiederhergestellte aufgeklappte Patienten:', expandedArray);
            }
          } catch (e) {
            console.warn('Fehler beim Wiederherstellen der aufgeklappten Patienten:', e);
            window.expandedPatients = new Set();
          }
        } else {
          window.expandedPatients = new Set();
        }

        // Patienten initial laden
        loadPatients();
        
        // Scroll-Position nach Reload wiederherstellen
        const savedScrollPosition = sessionStorage.getItem('scrollPosition');
        if (savedScrollPosition) {
          const scrollY = parseInt(savedScrollPosition, 10);
          if (!isNaN(scrollY)) {
            setTimeout(() => {
              window.scrollTo(0, scrollY);
              console.log('Scroll-Position nach RTM-Reload wiederhergestellt:', scrollY);
            }, 300); // Etwas länger warten damit die Patienten vollständig geladen sind
          }
          // Position nach Verwendung löschen
          sessionStorage.removeItem('scrollPosition');
        }
      });

      function formatMS(ms) {
        if (!isFinite(ms) || ms < 0) return "–";
        const totalSec = Math.floor(ms / 1000);
        const mm = String(Math.floor(totalSec / 60)).padStart(2, "0");
        const ss = String(totalSec % 60).padStart(2, "0");
        return `${mm}:${ss}`;
      }

      /**
       * Deaktiviert alle Checkboxen mit demselben name außer der gerade geklickten.
       */
      function selectOnly(box) {
        const gruppe = document.getElementsByName(box.name);
        gruppe.forEach((cb) => {
          if (cb !== box) cb.checked = false;
        });
        // Falls der Klick eine Checkbox deaktiviert hat, sorgen wir dafür,
        // dass mindestens eine immer ausgewählt bleibt:
        if (!box.checked) {
          box.checked = true;
        }
      }

      function promptAddEntry(id) {
        const text = prompt("Bitte Eintrag eingeben:");
        if (text && text.trim()) {
          addCustomHistory(id, text.trim());
        }
      }

      // Funktion um Disposition-Status nach Diagnose-Änderung zu aktualisieren
      function updateDispositionAfterDiagnosisChange(patientId) {
        // Patient-Karten neu laden um die aktualisierten Disposition-Symbole anzuzeigen
        if (typeof loadPatients === 'function') {
          loadPatients(patientId);
        }
        
        // Auch Trupp-Karten aktualisieren falls sie Disposition-Symbole anzeigen
        if (typeof updatePatientDispositionStatus === 'function') {
          const patients = JSON.parse(localStorage.getItem("patients")) || [];
          const patient = patients.find(p => p.id === patientId);
          if (patient) {
            const trupps = JSON.parse(localStorage.getItem("trupps")) || [];
            const rtms = JSON.parse(localStorage.getItem("rtms")) || [];
            updatePatientDispositionStatus(patient, trupps, rtms);
          }
        }
      }

      window.addEventListener("storage", (e) => {
        // NEUE FREEZE-LOGIK: Prüfe ob Seite eingefroren ist
        const isPageFrozen = window.expandedPatients && window.expandedPatients.size > 0;
        
        if (e.key === "trupps") {
          // Bei aufgeklappten Patienten trotzdem kritische Updates durchführen
          if (isPageFrozen) {
            console.log('Trupp-Update bei eingefrorener Seite - nur Datenlogik ohne UI-Refresh');
            // Führe die kritische Datenlogik aus ohne UI-Updates
            const newTrupps = JSON.parse(e.newValue || "[]");
            const patients = JSON.parse(localStorage.getItem("patients")) || [];
            let dirty = false;

            // Entferne Trupps von Patienten die nicht mehr verfügbar sind
            patients.forEach((patient) => {
              const isFinalState = patient.status === "Entlassen" || 
                                  patient.status === "Transport in KH" ||
                                  patient.transport ||
                                  patient.discharge;
              
              if (isFinalState || !Array.isArray(patient.team)) return;

              const keepStatuses = [3, 4, 7, 8];
              const before = [...patient.team];
              patient.team = patient.team.filter((name) => {
                const t = newTrupps.find((x) => x.name === name);
                return t && keepStatuses.includes(t.status);
              });

              before.forEach((name) => {
                if (!patient.team.includes(name)) {
                  patient.history = patient.history || [];
                  patient.history.push(
                    `${getCurrentTime()} Trupp ${name} entfernt (via Trupp-Tracker)`
                  );
                  dirty = true;
                }
              });

              // Status zurücksetzen falls keine Ressourcen mehr
              const noTrupp = !Array.isArray(patient.team) || patient.team.length === 0;
              const noRtm = !Array.isArray(patient.rtm) || patient.rtm.length === 0;
              if (noTrupp && noRtm && patient.status !== "gemeldet") {
                patient.status = "gemeldet";
                patient.history = patient.history || [];
                patient.history.push(`${getCurrentTime()} Status: gemeldet`);
                dirty = true;
              }
            });

            if (dirty) {
              localStorage.setItem("patients", JSON.stringify(patients));
            }
            return;
          }
          
          // 1) Scroll-Position merken
          const currentScrollY = window.scrollY;
          
          // 2) Trupps aus dem Storage parsen
          const newTrupps = JSON.parse(e.newValue || "[]");
          // 3) immer neu rendern, damit frisch angemeldete Trupps im Patientendropdown auftauchen
          loadPatients();

          // 4) Scroll-Position wiederherstellen
          setTimeout(() => {
            window.scrollTo(0, currentScrollY);
          }, 100);

          // 5) jetzt erst die Patienten aus Storage holen
          const patients = JSON.parse(localStorage.getItem("patients")) || [];
          let dirty = false;

          // 6) Entferne alle Trupp-Namen, die nicht mehr Status 3 haben
patients.forEach((patient) => {
  // WICHTIG: Finale Status schützen - erweiterte Prüfung
  const isFinalState = patient.status === "Entlassen" || 
                      patient.status === "Transport in KH" ||
                      patient.transport ||  // Hat Transport-Ziel
                      patient.discharge;    // Hat Entlassungsort
  
  if (isFinalState) return;
  
  if (!Array.isArray(patient.team)) return;

  const keepStatuses = [3, 4, 7, 8];              // diese Status sollen behalten werden
  const before = [...patient.team];
  patient.team = patient.team.filter((name) => {
    const t = newTrupps.find((x) => x.name === name);
    return t && keepStatuses.includes(t.status);
  });

  before.forEach((name) => {
    if (!patient.team.includes(name)) {
      patient.history = patient.history || [];
      patient.history.push(
        `${getCurrentTime()} Trupp ${name} entfernt (via Trupp-Tracker)`
      );
      dirty = true;
    }
            });
          });

          // 7) Falls jetzt keine Trupps oder RTMs mehr dran hängen → zurück auf "gemeldet"
          // ABER NUR wenn Patient nicht in finalem Status ist
          patients.forEach((patient) => {
            // WICHTIG: Finale Status schützen - erweiterte Prüfung
            const isFinalState = patient.status === "Entlassen" || 
                                patient.status === "Transport in KH" ||
                                patient.transport ||  // Hat Transport-Ziel
                                patient.discharge;    // Hat Entlassungsort
            
            if (isFinalState) return;
            
            const noTrupp =
              !Array.isArray(patient.team) || patient.team.length === 0;
            const noRtm =
              !Array.isArray(patient.rtm) || patient.rtm.length === 0;
            if (noTrupp && noRtm && patient.status !== "gemeldet") {
              patient.status = "gemeldet";
              patient.history = patient.history || [];
              patient.history.push(`${getCurrentTime()} Status: gemeldet`);
              dirty = true;
            }
          });

          // 8) Wenn sich etwas geändert hat, speichern & neu rendern
          if (dirty) {
            localStorage.setItem("patients", JSON.stringify(patients));
            loadPatients();
          }
        }
        
        if (e.key === "patients") {
          // WICHTIGE ÄNDERUNG: Auch bei eingefrorener Seite kritische Patient-Updates durchführen
          if (isPageFrozen) {
            console.log('Patient-Update bei eingefrorener Seite - führe kritische Updates durch');
            
            // Versuche zu erkennen ob es sich um einen wichtigen Status-Update handelt
            const newPatients = JSON.parse(e.newValue || "[]");
            const oldPatients = JSON.parse(e.oldValue || "[]");
            
            let hasStatusChanges = false;
            
            // Prüfe auf Status-Änderungen
            newPatients.forEach(newPatient => {
              const oldPatient = oldPatients.find(p => p.id === newPatient.id);
              if (oldPatient && oldPatient.status !== newPatient.status) {
                console.log(`Status-Änderung erkannt: Patient ${newPatient.id} von "${oldPatient.status}" zu "${newPatient.status}"`);
                hasStatusChanges = true;
              }
            });
            
            // Bei kritischen Änderungen trotzdem UI aktualisieren
            if (hasStatusChanges) {
              console.log('Kritische Status-Änderungen erkannt - aktualisiere UI trotz Freeze');
              const currentScrollY = window.scrollY;
              loadPatients();
              setTimeout(() => {
                window.scrollTo(0, currentScrollY);
              }, 100);
            }
            return;
          }
          
          // Scroll-Position merken vor dem Neuladen
          const currentScrollY = window.scrollY;
          
          // Bei Patient-Änderungen nur neu laden, KEINE Disposition-Updates
          loadPatients();
          
          // Scroll-Position wiederherstellen
          setTimeout(() => {
            window.scrollTo(0, currentScrollY);
          }, 100);
          
          // REMOVED: triggerDispositionUpdate() - was causing save conflicts
          // Disposition updates will be handled through direct logic in assignResource() etc.
        }

        if (e.key === "rtms") {
          // Bei aufgeklappten Patienten trotzdem kritische RTM-Updates durchführen
          if (isPageFrozen) {
            console.log('RTM-Update bei eingefrorener Seite - führe kritische Updates durch');
            
            // RTMs aus dem Storage parsen
            const newRtms = JSON.parse(e.newValue || "[]");
            const oldRtms = JSON.parse(e.oldValue || "[]");
            
            // Prüfen ob sich ein Status geändert hat
            let statusChanged = false;
            if (oldRtms.length !== newRtms.length) {
              statusChanged = true;
            } else {
              // Vergleiche Status aller RTMs
              for (let i = 0; i < newRtms.length; i++) {
                const newRtm = newRtms[i];
                const oldRtm = oldRtms.find(r => r.name === newRtm.name);
                if (!oldRtm || oldRtm.status !== newRtm.status) {
                  statusChanged = true;
                  console.log(`RTM Status-Änderung erkannt: ${newRtm.name} von ${oldRtm?.status || 'unbekannt'} zu ${newRtm.status}`);
                  break;
                }
              }
            }
            
            // Bei Status-Änderungen die Datenlogik ausführen
            if (statusChanged) {
              console.log('RTM Status-Änderung erkannt - führe Datenlogik aus');
              
              // Prüfen ob RTMs von Patienten entfernt werden müssen
              const patients = JSON.parse(localStorage.getItem("patients")) || [];
              let dirty = false;

              patients.forEach((patient) => {
                // WICHTIG: Finale Status schützen
                const isFinalState = patient.status === "Entlassen" || 
                                    patient.status === "Transport in KH" ||
                                    patient.transport ||
                                    patient.discharge;
                
                if (isFinalState) return;
                
                if (!Array.isArray(patient.rtm)) return;

                const keepStatuses = [3, 4, 7, 8]; // verfügbare RTM-Status
                const before = [...patient.rtm];
                patient.rtm = patient.rtm.filter((name) => {
                  const r = newRtms.find((x) => x.name === name);
                  return r && keepStatuses.includes(r.status);
                });

                before.forEach((name) => {
                  if (!patient.rtm.includes(name)) {
                    patient.history = patient.history || [];
                    patient.history.push(
                      `${getCurrentTime()} RTM ${name} entfernt (via RTM-Tracker)`
                    );
                    dirty = true;
                  }
                });
              });

              // Status auf "gemeldet" zurücksetzen wenn keine Ressourcen mehr
              patients.forEach((patient) => {
                const isFinalState = patient.status === "Entlassen" || 
                                    patient.status === "Transport in KH" ||
                                    patient.transport ||
                                    patient.discharge;
                
                if (isFinalState) return;
                
                const noTrupp = !Array.isArray(patient.team) || patient.team.length === 0;
                const noRtm = !Array.isArray(patient.rtm) || patient.rtm.length === 0;
                if (noTrupp && noRtm && patient.status !== "gemeldet") {
                  patient.status = "gemeldet";
                  patient.history = patient.history || [];
                  patient.history.push(`${getCurrentTime()} Status: gemeldet`);
                  dirty = true;
                }
              });

              // Disposition-Symbole für alle Patienten aktualisieren
              if (typeof updatePatientDispositionStatus === 'function') {
                const trupps = JSON.parse(localStorage.getItem("trupps")) || [];
                patients.forEach(patient => {
                  updatePatientDispositionStatus(patient, trupps, newRtms);
                });
                dirty = true;
              }

              // Wenn sich etwas geändert hat, speichern
              if (dirty) {
                localStorage.setItem("patients", JSON.stringify(patients));
                console.log('RTM-Änderung verarbeitet, Patientendaten aktualisiert');
              }
            }
            return;
          }
          
          // RTM-Änderungen behandeln
          const currentScrollY = window.scrollY;
          
          // RTMs aus dem Storage parsen
          const newRtms = JSON.parse(e.newValue || "[]");
          const oldRtms = JSON.parse(e.oldValue || "[]");
          
          // Prüfen ob sich ein Status geändert hat
          let statusChanged = false;
          if (oldRtms.length !== newRtms.length) {
            statusChanged = true;
          } else {
            // Vergleiche Status aller RTMs
            for (let i = 0; i < newRtms.length; i++) {
              const newRtm = newRtms[i];
              const oldRtm = oldRtms.find(r => r.name === newRtm.name);
              if (!oldRtm || oldRtm.status !== newRtm.status) {
                statusChanged = true;
                console.log(`RTM Status-Änderung erkannt: ${newRtm.name} von ${oldRtm?.status || 'unbekannt'} zu ${newRtm.status}`);
                break;
              }
            }
          }
          
          // PROBEWEISE: Komplette Seite neu laden bei RTM-Status-Änderung
          if (statusChanged) {
            console.log('RTM Status-Änderung erkannt - lade Seite neu');
            
            // Scroll-Position für nach dem Reload speichern
            sessionStorage.setItem('scrollPosition', currentScrollY.toString());
            
            // Seite neu laden
            window.location.reload();
            return; // Exit early da die Seite neu geladen wird
          }
          
          // Fallback falls keine Status-Änderung erkannt wurde
          // Patienten trotzdem neu rendern um andere RTM-Änderungen zu reflektieren
          loadPatients();

          // Scroll-Position wiederherstellen
          setTimeout(() => {
            window.scrollTo(0, currentScrollY);
          }, 100);
          
          // Prüfen ob RTMs von Patienten entfernt werden müssen
          const patients = JSON.parse(localStorage.getItem("patients")) || [];
          let dirty = false;

          patients.forEach((patient) => {
            // WICHTIG: Finale Status schützen
            const isFinalState = patient.status === "Entlassen" || 
                                patient.status === "Transport in KH" ||
                                patient.transport ||
                                patient.discharge;
            
            if (isFinalState) return;
            
            if (!Array.isArray(patient.rtm)) return;

            const keepStatuses = [3, 4, 7, 8]; // verfügbare RTM-Status
            const before = [...patient.rtm];
            patient.rtm = patient.rtm.filter((name) => {
              const r = newRtms.find((x) => x.name === name);
              return r && keepStatuses.includes(r.status);
            });

            before.forEach((name) => {
              if (!patient.rtm.includes(name)) {
                patient.history = patient.history || [];
                patient.history.push(
                  `${getCurrentTime()} RTM ${name} entfernt (via RTM-Tracker)`
                );
                dirty = true;
              }
            });
          });

          // Status auf "gemeldet" zurücksetzen wenn keine Ressourcen mehr
          patients.forEach((patient) => {
            const isFinalState = patient.status === "Entlassen" || 
                                patient.status === "Transport in KH" ||
                                patient.transport ||
                                patient.discharge;
            
            if (isFinalState) return;
            
            const noTrupp = !Array.isArray(patient.team) || patient.team.length === 0;
            const noRtm = !Array.isArray(patient.rtm) || patient.rtm.length === 0;
            if (noTrupp && noRtm && patient.status !== "gemeldet") {
              patient.status = "gemeldet";
              patient.history = patient.history || [];
              patient.history.push(`${getCurrentTime()} Status: gemeldet`);
              dirty = true;
            }
          });

          // Disposition-Symbole für alle Patienten aktualisieren - CRITICAL FIX
          if (typeof updatePatientDispositionStatus === 'function') {
            const trupps = JSON.parse(localStorage.getItem("trupps")) || [];
            patients.forEach(patient => {
              updatePatientDispositionStatus(patient, trupps, newRtms);
            });
            dirty = true; // Ensure patients are saved after disposition update
          }

          // Wenn sich etwas geändert hat, speichern & neu rendern
          if (dirty) {
            localStorage.setItem("patients", JSON.stringify(patients));
            loadPatients();
          }
          
          // Zusätzlich: Patienten neu rendern bei jeder RTM-Status-Änderung
          // um aktuelle Verfügbarkeit/Status in der Anzeige zu reflektieren
          setTimeout(() => {
            loadPatients();
          }, 200);
          
          console.log('RTM-Änderung verarbeitet, Disposition-Symbole aktualisiert, Patienten neu geladen');
        }
      });

      // ENTER-Taste in Modal abfangen und bestätigen
      document.addEventListener("keydown", function (e) {
        const modal = document.getElementById("keywordModal");
        if (modal && modal.style.display === "flex" && e.key === "Enter") {
          e.preventDefault();
          confirmEdit();
        }
      });

      // DISPOSITION UPDATE LISTENER COMPLETELY DISABLED
      // This was causing conflicts with patient data saving
      // Disposition updates will happen through normal save operations only
      
      if (window.dispositionUpdateListener) {
        window.removeEventListener('dispositionUpdate', window.dispositionUpdateListener);
        window.dispositionUpdateListener = null;
      }
      
      // Remove the save flag as well
      window.isSavingPatientData = false;

      // Kontextmenü-Funktionen global verfügbar machen
      window.hidePatientContextMenu = hidePatientContextMenu;

      // NEUE FUNKTION: Periodisches Backup der erweiterten Zustände
      // Falls das System abstürzt oder neu geladen wird
      setInterval(() => {
        if (window.expandedPatients && window.expandedPatients.size > 0) {
          // Speichere die IDs der aufgeklappten Patienten in sessionStorage
          const expandedArray = Array.from(window.expandedPatients);
          sessionStorage.setItem('expandedPatients', JSON.stringify(expandedArray));
        }
      }, 2000); // Alle 2 Sekunden speichern

      // NEUE FUNKTION: Wiederherstellen beim Seitenladen
      document.addEventListener('DOMContentLoaded', () => {
        // Versuche erweiterte Zustände aus sessionStorage wiederherzustellen
        const savedExpanded = sessionStorage.getItem('expandedPatients');
        if (savedExpanded) {
          try {
            const expandedArray = JSON.parse(savedExpanded);
            if (Array.isArray(expandedArray)) {
              window.expandedPatients = new Set(expandedArray);
              console.log('Wiederhergestellte aufgeklappte Patienten:', expandedArray);
            }
          } catch (e) {
            console.warn('Fehler beim Wiederherstellen der aufgeklappten Patienten:', e);
            window.expandedPatients = new Set();
          }
        } else {
          window.expandedPatients = new Set();
        }
      });

      // Cleanup bei Page-Unload falls nötig
      window.addEventListener('beforeunload', () => {
        if (window.expandedPatients && window.expandedPatients.size > 0) {
          const expandedArray = Array.from(window.expandedPatients);
          sessionStorage.setItem('expandedPatients', JSON.stringify(expandedArray));
        }
      });

      // Initialisierung - füge dies in deine Haupt-HTML oder init-Datei ein
document.addEventListener('DOMContentLoaded', function() {
  // Stelle sicher, dass expandedPatients Set existiert und leer ist
  window.expandedPatients = new Set();
});
    </script>
  </body>
</html>